// ***********************************************************************
// Assembly         : KsWare.CodeGenerator
// Author           : SchreinerK
// Created          : 2018-03-29
//
// Last Modified By : SchreinerK
// Last Modified On : 2018-03-29
// ***********************************************************************
// <copyright file="WrapperGenerator.cs" company="KsWare">
//     Copyright © 2018 KsWare. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text;
using KsWare.CodeGenerator.Extensions;

namespace KsWare.CodeGenerator {

	/// <summary>
	/// Class WrapperGenerator.
	/// </summary>
	/// <autogeneratedoc />
	public class WrapperGenerator {

		/// <summary>
		/// The default wrapper generator.
		/// </summary>
		public static readonly WrapperGenerator Default = new WrapperGenerator();

		private WrapperGenerator() { }

		[SuppressMessage("ReSharper", "UnusedMember.Local")]
		private static string LocalTest() { return Default.Generate(typeof(MethodInfo)); }

		/// <summary>
		/// Generates wrapper for the specified type.
		/// </summary>
		/// <param name="type">The type wrap.</param>
		/// <returns>The C# code.</returns>
		/// <autogeneratedoc />
		public string Generate(Type type) {
			var sb = new StringBuilder();
			sb.AppendLine("namespace NAMESPACE {" + "\n");
			sb.AppendLine("\t" + "public class WRAPPER {" + "\n");

			var events = type.GetEvents(BindingFlags.Static | BindingFlags.Public);
			foreach (var e in events) Generate(e, sb);

			var properties = type.GetProperties(BindingFlags.Static | BindingFlags.Public);
			foreach (var p in properties) Generate(p, sb);

			var methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public);
			foreach (var m in methods) Generate(m, sb);

			sb.AppendLine("\t\t" + $"private readonly {Generator.ForDeclare.Generate(type)} _wrappedInstance;" + "\n");
			sb.AppendLine("\t\t" + $"public WRAPPER({Generator.ForDeclare.Generate(type)} wrappedInstance) {{ _wrappedInstance = wrappedInstance; }}" + "\n");

			events = type.GetEvents(BindingFlags.Instance | BindingFlags.Public);
			foreach (var e in events) Generate(e, sb);

			properties = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
			foreach (var p in properties) Generate(p, sb);

			methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public);
			foreach (var m in methods) Generate(m, sb);

			sb.AppendLine("\t" + "}");
			sb.Append("}");
			return sb.ToString();
		}

//		public event EventHandler E { add { _wrappedInstance.E += value; } remove { _wrappedInstance.E -= value; } }

		private void Generate(EventInfo e, StringBuilder sb) {
			var dtype= Generator.ForInheriteDoc.Generate(e.ReflectedType);
			var ds = Generator.ForInheriteDoc.Generate(e);
			var rtype = Generator.ForCall.Generate(e.ReflectedType);
			var type = Generator.ForCall.Generate(e.EventHandlerType);
			var name = e.Name;

			sb.AppendLine("\t\t" + $@"/// <inheritdoc cref=""{dtype}.{ds}""/>");
			if (e.GetAddMethod().IsStatic) {
				sb.AppendLine("\t\t" + $"public static event {type} {name} {{ add {{ {rtype}.{name} += value; }} remove {{ {rtype}.{name} -= value; }} }}");
			}
			else {
				sb.AppendLine("\t\t" + $"public event {type} {name} {{ add {{ _wrappedInstance.{name} += value; }} remove {{ _wrappedInstance.{name} -= value; }} }}");
			}
		}

		private static readonly string[] SpecialNamePrefixes = new[] {"get_", "set_", "add_", "remove_"};

		private void Generate(MethodInfo m, StringBuilder sb) {
			var dtype = Generator.ForSignature.Generate(m.DeclaringType);
			var mdoc = Generator.ForInheriteDoc.Generate(m);
			var name = m.Name;
			var type = Generator.ForCall.Generate(m.ReturnType);
			//TODO exlude property methods get_ set_
			//TODO exlude event methods add_ remove_
			//TODO overload operators

			if(IsOtherSpecialMethod(m)) return;

			if (m.IsOperatorOverload()) {
				sb.AppendLine("\t\t" + $"// {name} not implemented"); // TODO
			}
			else if (m.IsStatic && !m.IsOperatorOverload()) {
				var invokeParameter = Generator.ForCall.Generate(m.GetParameters());
				var body            = $" => {type}.{name}({invokeParameter});";
				var declareParameters = Generator.ForDeclare.Generate(m.GetParameters());
				sb.AppendLine("\t\t" + $@"/// <inheritdoc cref=""{dtype}.{mdoc}""/>");
				sb.AppendLine("\t\t" + $"public static {type} {name}({declareParameters}) {body}");	
			}
			else  {
				var invokeParameter = Generator.ForCall.Generate(m.GetParameters());
				var body = $" => _wrappedInstance.{name}({invokeParameter});";
				var declareParameters = Generator.ForDeclare.Generate(m.GetParameters());
				sb.AppendLine("\t\t" + $@"/// <inheritdoc cref=""{dtype}.{mdoc}""/>");
				sb.AppendLine("\t\t" + $"public {type} {name}({declareParameters}) {body}");				
			}
		}

		private bool IsOtherSpecialMethod(MethodInfo methodInfo) {
			if (methodInfo.IsSpecialName) {
				var n = methodInfo.Name;
				foreach (var prefix in SpecialNamePrefixes) {
					if (n.StartsWith(prefix)) return true; // TODO revise. not 100% safe.
				}
			}
			return false;
		}

		private void Generate(PropertyInfo p, StringBuilder sb) {
			var dn = Generator.ForInheriteDoc.Generate(p.DeclaringType);
			var ds = Generator.ForInheriteDoc.Generate(p);
			sb.AppendLine("\t\t" + $@"/// <inheritdoc cref=""{dn}.{ds}""/>");

			var type = Generator.ForCall.Generate(p.PropertyType);
			var name = p.Name;

			if ((p.GetGetMethod() ?? p.GetSetMethod()).IsStatic) {
				var rtype = Generator.ForCall.Generate(p.ReflectedType);
				if (p.CanRead && p.CanWrite) {
					sb.AppendLine("\t\t" + $"public static {type} {name} {{ get => {rtype}.{name}; set => {rtype}.{name} = value; }}");
				}else if (p.CanRead) {
					sb.AppendLine("\t\t" + $"public static {type} {name} {{ get => {rtype}.{name}; }}");
				}else if (p.CanWrite) {
					sb.AppendLine("\t\t" + $"public static {type} {name} {{ set => {rtype}.{name} = value; }}");
				}

			} else if (name == "Item") {
				var declareParameters = Generator.ForDeclare.Generate(p.GetIndexParameters());
				var invokeParameters = Generator.ForCall.Generate(p.GetIndexParameters());
				if (p.CanRead && p.CanWrite) {
					sb.AppendLine("\t\t" + $"public {type} this[{declareParameters}] {{ get => _wrappedInstance[{invokeParameters}]; set => _wrappedInstance[{invokeParameters}] = value; }}");
				}else if (p.CanRead) {
					sb.AppendLine("\t\t" + $"public {type} this[{declareParameters}] {{ get => _wrappedInstance[{invokeParameters}]; }}");
				}else if (p.CanWrite) {
					sb.AppendLine("\t\t" + $"public {type} this[{declareParameters}] {{ set => _wrappedInstance[{invokeParameters}] = value; }}");
				}
			}
			else {
				if (p.CanRead && p.CanWrite) {
					sb.AppendLine("\t\t" + $"public {type} {name} {{ get => _wrappedInstance.{name}; set => _wrappedInstance.{name} = value; }}");
				}else if (p.CanRead) {
					sb.AppendLine("\t\t" + $"public {type} {name} {{ get => _wrappedInstance.{name}; }}");
				}else if (p.CanWrite) {
					sb.AppendLine("\t\t" + $"public {type} {name} {{ set => _wrappedInstance.{name} = value; }}");
				}
			}
		}

	}

}
